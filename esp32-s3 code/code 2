#include <Arduino.h>
#include <Wire.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <stddef.h>
#include <math.h>
#include <time.h>

#pragma pack(push, 1)
struct SurfaceSBD {
  uint8_t  proto_ver;
  uint8_t  msg_type;
  uint32_t tag_id;
  uint8_t  fw_ver;
  uint16_t seq;
  uint32_t ts_utc;
  uint16_t surface_ms;
  uint8_t  wetdry_state;
  uint16_t depth_cm;
  uint16_t depth_min_cm;
  uint16_t depth_max_cm;
  int16_t  ascent_rate_cmps;
  uint16_t last_dive_max_cm;
  uint16_t last_dive_dur_s;
  uint16_t surface_pause_s;
  int16_t  T_water_centi;
  uint16_t imu_rms_mg;
  uint16_t imu_jerk_peak;
  uint16_t imu_gyro_rms_dps;
  uint8_t  bite_score;
  uint8_t  act_level;
  uint16_t freq_peak_hz100;
  uint16_t v_batt_mv;
  int8_t   temp_board_c;
  uint8_t  tx_attempts;
  uint8_t  q_flags;
  uint8_t  reserve[8];
  uint16_t crc16;
};
#pragma pack(pop)

void wetdryInit();
void updateWetDry();
void fillSurface(SurfaceSBD& p, float& geoLat, float& geoLon);
void printSurfaceHuman(const SurfaceSBD& p, float geoLat, float geoLon);
uint16_t crc16_ccitt(const uint8_t* data, size_t len);
int16_t i2cRead16(uint8_t reg);
bool mpuInit();
void computeIMU(uint16_t& rms_mg, uint16_t& gyro_rms, uint16_t& jerk_peak,
                uint8_t& bite_score, uint8_t& act_level, uint16_t& fpk_hz100);

constexpr int PIN_I2C_SDA = 8;
constexpr int PIN_I2C_SCL = 9;
constexpr int PIN_DS18B20 = 4;
constexpr int PIN_WETDRY  = 5;
constexpr int PIN_LED     = 2;

OneWire oneWire(PIN_DS18B20);
DallasTemperature dallas(&oneWire);
constexpr uint8_t MPU_ADDR = 0x68;
constexpr uint8_t REG_PWR_MGMT_1   = 0x6B;
constexpr uint8_t REG_ACCEL_XOUT_H = 0x3B;
constexpr uint8_t REG_GYRO_XOUT_H  = 0x43;

uint16_t crc16_ccitt(const uint8_t* data, size_t len) {
  uint16_t crc = 0xFFFF;
  for (size_t i = 0; i < len; ++i) {
    crc ^= (uint16_t)data[i] << 8;
    for (int b = 0; b < 8; ++b)
      crc = (crc & 0x8000) ? ((crc << 1) ^ 0x1021) : (crc << 1);
  }
  return crc;
}

int16_t i2cRead16(uint8_t reg) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(reg);
  if (Wire.endTransmission(false) != 0) return 0;
  if (Wire.requestFrom((int)MPU_ADDR, 2) != 2) return 0;
  return (int16_t)((Wire.read() << 8) | Wire.read());
}
bool mpuInit() {
  Wire.beginTransmission(MPU_ADDR);
  if (Wire.endTransmission() != 0) return false;
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(REG_PWR_MGMT_1);
  Wire.write(0x00);
  return Wire.endTransmission() == 0;
}

#define  WET_ACTIVE_LOW 1
const uint16_t T_STABLE_MS = 2000;

struct WetDrySM {
  bool     prevDry = false;
  uint32_t tDryMs  = 0;
  uint16_t surface_ms = 0;
  uint8_t  mask = 0;
} wd;

void wetdryInit() {
  pinMode(PIN_WETDRY, INPUT_PULLUP);
  pinMode(PIN_LED, OUTPUT);
}

inline bool readWet() {
  int raw = digitalRead(PIN_WETDRY);
#if WET_ACTIVE_LOW
  return raw == LOW;
#else
  return raw == HIGH;
#endif
}

void updateWetDry() {
  bool isWet = readWet();
  bool isDry = !isWet;

  bool edgeDry = isDry && !wd.prevDry;
  if (edgeDry) wd.tDryMs = millis();

  wd.surface_ms = isDry
      ? (uint16_t)min<uint32_t>(UINT16_MAX, millis() - wd.tDryMs)
      : 0;

  uint8_t m = 0;
  if (isDry) m |= 1 << 0;
  if (isDry && wd.surface_ms >= T_STABLE_MS) m |= 1 << 1;
  if (edgeDry) m |= 1 << 2;
  wd.mask = m;
  wd.prevDry = isDry;

  digitalWrite(PIN_LED, isDry ? HIGH : LOW);
}

uint16_t g_seq = 1;
uint32_t g_tag_id = 0x1234ABCD;
uint8_t  g_fw_ver = 3;

void computeIMU(uint16_t& rms_mg, uint16_t& gyro_rms, uint16_t& jerk_peak,
                uint8_t& bite_score, uint8_t& act_level, uint16_t& fpk_hz100) {
  int16_t ax = i2cRead16(REG_ACCEL_XOUT_H);
  int16_t ay = i2cRead16(REG_ACCEL_XOUT_H + 2);
  int16_t az = i2cRead16(REG_ACCEL_XOUT_H + 4);
  int16_t gx = i2cRead16(REG_GYRO_XOUT_H);
  int16_t gy = i2cRead16(REG_GYRO_XOUT_H + 2);
  int16_t gz = i2cRead16(REG_GYRO_XOUT_H + 4);

  float axg = ax / 16384.0f;
  float ayg = ay / 16384.0f;
  float azg = az / 16384.0f;
  float gxd = gx / 131.0f;
  float gyd = gy / 131.0f;
  float gzd = gz / 131.0f;

  float accMagG = sqrtf(axg*axg + ayg*ayg + azg*azg);
  float gyroMag = sqrtf(gxd*gxd + gyd*gyd + gzd*gzd);

  rms_mg    = (uint16_t)roundf(fabs(accMagG - 1.0f) * 1000.0f);
  gyro_rms  = (uint16_t)roundf(gyroMag);
  jerk_peak = min<uint16_t>(rms_mg * 4, 2000);
  act_level = (uint8_t)min<int>(100, rms_mg / 8);
  bite_score= (uint8_t)min<int>(100, (int)(gyroMag * 2 + (rms_mg > 80 ? 10 : 0)));
  fpk_hz100 = 625;
}

int8_t   getBoardTempC() { return 28; }
uint16_t getVBattMv()    { return 7200; }

void fillSurface(SurfaceSBD& p, float& geoLat, float& geoLon) {
  memset(&p, 0, sizeof(p));
  p.proto_ver = 1;
  p.msg_type  = 1;
  p.tag_id    = g_tag_id;
  p.fw_ver    = g_fw_ver;
  p.seq       = g_seq++;
  p.ts_utc    = (uint32_t)(time(nullptr));

  p.surface_ms   = wd.surface_ms;
  p.wetdry_state = wd.mask;

  p.depth_cm         = 0xFFFF;
  p.depth_min_cm     = 0xFFFF;
  p.depth_max_cm     = 0xFFFF;
  p.ascent_rate_cmps = (int16_t)0x8000;
  p.last_dive_max_cm = 0xFFFF;
  p.last_dive_dur_s  = 0xFFFF;
  p.surface_pause_s  = 0xFFFF;

  dallas.requestTemperatures();
  float tw = dallas.getTempCByIndex(0);
  p.T_water_centi = (tw > -100 && tw < 150) ? (int16_t)lroundf(tw * 100.0f)
                                            : (int16_t)0x8000;

  uint16_t rms_mg=0, gyro_rms=0, jerk_peak=0, fpk_hz100=0; uint8_t bite=0, act=0;
  computeIMU(rms_mg, gyro_rms, jerk_peak, bite, act, fpk_hz100);
  p.imu_rms_mg       = rms_mg;
  p.imu_gyro_rms_dps = gyro_rms;
  p.imu_jerk_peak    = jerk_peak;
  p.bite_score       = bite;
  p.act_level        = act;
  p.freq_peak_hz100  = fpk_hz100;

  p.v_batt_mv    = getVBattMv();
  p.temp_board_c = getBoardTempC();
  p.tx_attempts  = ((wd.mask & 0x03) == 0x03) ? 1 : 0;

  uint8_t q = 0;
  q |= 1 << 0;
  if (p.T_water_centi != (int16_t)0x8000) q |= 1 << 1;
  if (wd.mask & 0x01) q |= 1 << 3;
  q |= 1 << 4;
  p.q_flags = q;

  memset(p.reserve, 0, sizeof(p.reserve));
  p.crc16 = crc16_ccitt(reinterpret_cast<const uint8_t*>(&p), offsetof(SurfaceSBD, crc16));

  static float baseLat = 42.1234f;
  static float baseLon = -31.5678f;
  float t = (millis() % 60000) / 60000.0f;
  geoLat = baseLat + 0.01f * sinf(2 * PI * t);
  geoLon = baseLon + 0.01f * cosf(2 * PI * t);
}

void printSurfaceHuman(const SurfaceSBD& p, float geoLat, float geoLon) {
  Serial.println("SURFACE_SBD");
  Serial.printf("1) proto_ver: %u\n", p.proto_ver);
  Serial.printf("2) msg_type: %u\n", p.msg_type);
  Serial.printf("3) tag_id: %lu\n", (unsigned long)p.tag_id);
  Serial.printf("4) fw_ver: %u\n", p.fw_ver);
  Serial.printf("5) seq: %u\n", p.seq);
  Serial.printf("6) ts_utc: %lu\n", (unsigned long)p.ts_utc);
  Serial.printf("7) surface_ms: %u\n", p.surface_ms);

  const char* wd_txt = (p.wetdry_state & 0x01) ? "dry" : "wet";
  bool stable = (p.wetdry_state & 0x02);
  bool edge   = (p.wetdry_state & 0x04);
  Serial.printf("8) wetdry_state: 0x%02X (b0=dry b1=stable b2=edge) %s%s%s\n",
                p.wetdry_state,
                wd_txt,
                stable ? " stable" : "",
                edge   ? " edge"   : "");

  Serial.printf("9) depth_cm: %u\n", p.depth_cm);
  Serial.printf("10) depth_min_cm: %u\n", p.depth_min_cm);
  Serial.printf("11) depth_max_cm: %u\n", p.depth_max_cm);
  Serial.printf("12) ascent_rate_cmps: %d\n", p.ascent_rate_cmps);
  Serial.printf("13) last_dive_max_cm: %u\n", p.last_dive_max_cm);
  Serial.printf("14) last_dive_dur_s: %u\n", p.last_dive_dur_s);
  Serial.printf("15) surface_pause_s: %u\n", p.surface_pause_s);
  Serial.printf("16) T_water_centi: %d (%.2f C)\n", p.T_water_centi, p.T_water_centi/100.0);
  Serial.printf("17) imu_rms_mg: %u\n", p.imu_rms_mg);
  Serial.printf("18) imu_jerk_peak: %u\n", p.imu_jerk_peak);
  Serial.printf("19) imu_gyro_rms_dps: %u\n", p.imu_gyro_rms_dps);
  Serial.printf("20) bite_score: %u\n", p.bite_score);
  Serial.printf("21) act_level: %u\n", p.act_level);
  Serial.printf("22) freq_peak_hz100: %u (%.2f Hz)\n", p.freq_peak_hz100, p.freq_peak_hz100/100.0);
  Serial.printf("23) v_batt_mv: %u\n", p.v_batt_mv);
  Serial.printf("24) temp_board_c: %d\n", p.temp_board_c);
  Serial.printf("25) tx_attempts: %u\n", p.tx_attempts);
  Serial.printf("26) q_flags: 0x%02X\n", p.q_flags);
  Serial.printf("27) reserve[8]: 0x00..0x00\n");
  Serial.printf("28) crc16: 0x%04X\n", p.crc16);
  Serial.printf("29) geo_lat_deg: %.6f\n", geoLat);
  Serial.printf("30) geo_lon_deg: %.6f\n", geoLon);
  Serial.println("---");
}

void setup() {
  Serial.begin(115200);
  wetdryInit();
  Wire.begin(PIN_I2C_SDA, PIN_I2C_SCL, 400000);
  mpuInit();
  dallas.begin();
}

unsigned long tPrev = 0;
static uint8_t lastMask = 0xFF;
static bool lastIsDry = false;

void loop() {
  updateWetDry();

  bool isDry = (wd.mask & 0x01) != 0;
  bool changed = (wd.mask != lastMask) || (isDry != lastIsDry);
  if (changed) {
    Serial.printf("wetdry_state: 0x%02X (b0=dry b1=stable b2=edge) %s\n",
                  wd.mask, isDry ? "dry" : "wet");
    lastMask = wd.mask;
    lastIsDry = isDry;
  }

  if (millis() - tPrev >= 2000) {
    tPrev = millis();
    SurfaceSBD pkt; float lat=0, lon=0;
    fillSurface(pkt, lat, lon);
    printSurfaceHuman(pkt, lat, lon);
  }

  delay(10);
}
